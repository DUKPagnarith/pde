---
title: "Empirical Examination of the Blackâ€“Scholes Model"
subtitle: "Evidence from the United States Stock Market"
author: "Financial Mathematics Research"
date: today
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: true
    code-summary: "Show code"
    theme: cosmo
    highlight-style: github
    number-sections: true
    fig-width: 10
    fig-height: 6
execute:
  warning: false
  message: false
jupyter: python3
---

# Introduction

## Background

Option pricing is crucial in enabling investors to hedge against risks in financial markets. The Blackâ€“Scholes option pricing model, developed by Fischer Black, Myron Scholes, and Robert Merton in 1973, remains one of the most widely used frameworks for pricing European-style options. This groundbreaking work earned Scholes and Merton the 1997 Nobel Prize in Economics.

The Blackâ€“Scholes model provides a theoretical framework for determining the fair price of options based on several key factors: the current stock price, strike price, time to expiration, risk-free interest rate, and volatility of the underlying asset. Despite its widespread adoption, the model relies on several simplifying assumptions that may not hold in real financial markets, including constant volatility, continuous trading, and log-normally distributed returns.

## Research Objective

This study investigates whether the Blackâ€“Scholes model is a good indicator of option pricing in the United States stock market. Following the methodology of Salami (2024), we examine the relevance of the Blackâ€“Scholes model to selected stocks using paired sample t-tests and the Corrado-Miller approximation for implied volatility.

The primary research questions are:

1. Is there a significant difference between actual market option prices and Blackâ€“Scholes theoretical prices?
2. Does the model perform differently for call options versus put options?
3. Are there systematic patterns in pricing errors across different stocks and sectors?

## Hypotheses

The hypotheses tested in this study are:

$$
H_0: \text{There is no significant difference between the actual market premium and the Blackâ€“Scholes premium}
$$

$$
H_1: \text{There is a significant difference between the actual market premium and the Blackâ€“Scholes premium}
$$

The null hypothesis is rejected at the 95% confidence level if the p-value is less than 0.05.

```{python}
#| label: setup
#| echo: true

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats import norm, ttest_rel, ttest_1samp
from scipy.optimize import brentq
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

# Plot settings
plt.style.use('seaborn-v0_8-whitegrid')
sns.set_palette("husl")
plt.rcParams['figure.figsize'] = (12, 6)
plt.rcParams['font.size'] = 11
```

---

# Methodology

## The Blackâ€“Scholes Model

The classical Blackâ€“Scholes model applies to non-dividend-paying assets and European-style options. However, this study uses the extended Blackâ€“Scholes model first introduced by Merton (1973), which incorporates dividend yields and can be applied to American-style options under certain conditions.

The extended Blackâ€“Scholes formulas for call and put options at time $t$ are:

**Call Option Premium:**
$$
C_t = S_t e^{-\delta T} \Phi(d_1) - K e^{-rT} \Phi(d_2)
$$

**Put Option Premium:**
$$
P_t = K e^{-rT} \Phi(-d_2) - S_t e^{-\delta T} \Phi(-d_1)
$$

where:
$$
d_1 = \frac{\ln(S_t/K) + (r - \delta + \sigma^2/2)T}{\sigma\sqrt{T}}
$$
$$
d_2 = d_1 - \sigma\sqrt{T}
$$

The variables are defined as:

- $S_t$ = Current stock price
- $K$ = Strike price
- $T$ = Time to expiration (in years)
- $r$ = Risk-free interest rate
- $\delta$ = Dividend yield
- $\sigma$ = Volatility
- $\Phi(\cdot)$ = Cumulative standard normal distribution function

## Implied Volatility Estimation

Since volatility is not directly observable, this study uses the Corrado-Miller (1996) approximation to estimate implied volatility from observed market prices.

For a call option, the implied volatility is approximated as:

$$
\sigma \approx \frac{\sqrt{2\pi}}{S e^{-\delta T} + K e^{-rT}} \left[ c_m - \frac{S e^{-\delta T} - K e^{-rT}}{2} + \sqrt{\left(c_m - \frac{S e^{-\delta T} - K e^{-rT}}{2}\right)^2 - \frac{(S e^{-\delta T} - K e^{-rT})^2}{\pi}} \right] / \sqrt{T}
$$

where $c_m$ is the market premium for the call option. A similar formula applies for put options, with appropriate sign changes.

## Statistical Testing

The paired sample t-test compares the mean difference between actual market premiums and Blackâ€“Scholes model premiums with zero. For sample sizes greater than 30, the normality assumption can be relaxed according to the Central Limit Theorem, as noted by Ghasemi and Zahediasl (2012).

The test statistic is:
$$
t = \frac{\bar{D}}{s_D / \sqrt{n}}
$$

where $\bar{D}$ is the mean difference, $s_D$ is the standard deviation of differences, and $n$ is the sample size.

---

# Data

## Stock Selection

Following Salami (2024), this study examines nine stocks from three sectors:

- **Financial Sector**: Bank of America (BAC), JPMorgan Chase (JPM), Wells Fargo (WFC)
- **Healthcare Sector**: Merck (MRK), Pfizer (PFE), UnitedHealth (UNH)
- **Technology Sector**: Apple (AAPL), Microsoft (MSFT), NVIDIA (NVDA)

This selection ensures sector diversification while focusing on large-cap, highly liquid stocks with active options markets.

## Data Sources

- **Stock Prices**: Yahoo Finance
- **Option Chains**: Yahoo Finance
- **Risk-Free Rate**: U.S. Federal Reserve (3-month Treasury rate)

The study period covers one month of trading data to capture recent market conditions.

```{python}
#| label: load-data
#| echo: true

# =============================================================================
# DATA LOADING
# =============================================================================

DATA_DIR = 'data'

def generate_sample_data():
    """Generate sample data for demonstration when real data is unavailable."""
    
    stocks = {
        'BAC': {'name': 'Bank of America', 'sector': 'Financial', 'spot': 37.50, 'div': 0.026},
        'JPM': {'name': 'JPMorgan Chase', 'sector': 'Financial', 'spot': 195.80, 'div': 0.023},
        'WFC': {'name': 'Wells Fargo', 'sector': 'Financial', 'spot': 58.20, 'div': 0.028},
        'MRK': {'name': 'Merck & Co.', 'sector': 'Healthcare', 'spot': 105.40, 'div': 0.027},
        'PFE': {'name': 'Pfizer Inc.', 'sector': 'Healthcare', 'spot': 27.30, 'div': 0.058},
        'UNH': {'name': 'UnitedHealth', 'sector': 'Healthcare', 'spot': 520.60, 'div': 0.014},
        'AAPL': {'name': 'Apple Inc.', 'sector': 'Technology', 'spot': 185.50, 'div': 0.005},
        'MSFT': {'name': 'Microsoft', 'sector': 'Technology', 'spot': 420.30, 'div': 0.007},
        'NVDA': {'name': 'NVIDIA', 'sector': 'Technology', 'spot': 875.40, 'div': 0.000}
    }
    
    dates = pd.date_range(end=datetime.now(), periods=22, freq='B')
    history_data = []
    
    for ticker, info in stocks.items():
        np.random.seed(hash(ticker) % 2**32)
        base_price = info['spot']
        returns = np.random.normal(0.0005, 0.015, len(dates))
        prices = base_price * np.exp(np.cumsum(returns))
        
        for i, date in enumerate(dates):
            history_data.append({
                'date': date, 'ticker': ticker, 'close': prices[i]
            })
    
    stock_history = pd.DataFrame(history_data)
    
    stock_info = pd.DataFrame([
        {'ticker': k, 'name': v['name'], 'sector': v['sector'], 
         'spot_price': v['spot'], 'dividend_yield': v['div']}
        for k, v in stocks.items()
    ])
    
    risk_free_rate = 0.045
    T = 35 / 365
    
    def bs_price(S, K, T, r, sigma, delta, opt_type):
        d1 = (np.log(S/K) + (r - delta + 0.5*sigma**2)*T) / (sigma*np.sqrt(T))
        d2 = d1 - sigma*np.sqrt(T)
        if opt_type == 'call':
            return S*np.exp(-delta*T)*norm.cdf(d1) - K*np.exp(-r*T)*norm.cdf(d2)
        else:
            return K*np.exp(-r*T)*norm.cdf(-d2) - S*np.exp(-delta*T)*norm.cdf(-d1)
    
    calls_data, puts_data = [], []
    
    for ticker, info in stocks.items():
        np.random.seed(hash(ticker + 'opt') % 2**32)
        S = info['spot']
        delta = info['div']
        
        if info['sector'] == 'Technology':
            base_vol = 0.35
        elif info['sector'] == 'Healthcare':
            base_vol = 0.25
        else:
            base_vol = 0.22
        
        atm = round(S / 5) * 5
        strikes = np.arange(atm - 20, atm + 25, 5)
        
        for K in strikes:
            moneyness = K / S
            sigma = base_vol * (1 + 0.1 * (moneyness - 1)**2) + np.random.normal(0, 0.01)
            sigma = max(0.10, min(0.80, sigma))
            
            call_theo = bs_price(S, K, T, risk_free_rate, sigma, delta, 'call')
            put_theo = bs_price(S, K, T, risk_free_rate, sigma, delta, 'put')
            
            call_market = max(0.01, call_theo * (1 + np.random.normal(0, 0.02)))
            put_market = max(0.01, put_theo * (1 + np.random.normal(0, 0.02)))
            
            vol = int(np.random.exponential(500) * np.exp(-2*(moneyness-1)**2) + 50)
            
            calls_data.append({
                'ticker': ticker, 'strike': K, 'lastPrice': round(call_market, 2),
                'impliedVolatility': sigma, 'volume': vol, 'T': T, 'days_to_expiry': 35
            })
            puts_data.append({
                'ticker': ticker, 'strike': K, 'lastPrice': round(put_market, 2),
                'impliedVolatility': sigma, 'volume': vol, 'T': T, 'days_to_expiry': 35
            })
    
    return stock_history, stock_info, pd.DataFrame(calls_data), pd.DataFrame(puts_data), risk_free_rate

# Load data
try:
    stock_history = pd.read_csv(f'{DATA_DIR}/stock_history.csv', parse_dates=['date'])
    stock_info = pd.read_csv(f'{DATA_DIR}/stock_info.csv')
    calls_df = pd.read_csv(f'{DATA_DIR}/options_calls.csv')
    puts_df = pd.read_csv(f'{DATA_DIR}/options_puts.csv')
    risk_free_df = pd.read_csv(f'{DATA_DIR}/risk_free_rate.csv')
    risk_free_rate = risk_free_df['rate'].iloc[-1]
    print("âœ“ Loaded real market data from CSV files")
except:
    stock_history, stock_info, calls_df, puts_df, risk_free_rate = generate_sample_data()
    print("âœ“ Using generated sample data for demonstration")

print(f"\nData Summary:")
print(f"  Stocks: {stock_info['ticker'].nunique()}")
print(f"  Call Options: {len(calls_df)}")
print(f"  Put Options: {len(puts_df)}")
print(f"  Risk-Free Rate: {risk_free_rate*100:.2f}%")
```

```{python}
#| label: display-stocks
#| echo: true

print("Selected Stocks:")
print("=" * 70)
display_df = stock_info[['ticker', 'name', 'sector', 'spot_price', 'dividend_yield']].copy()
display_df['spot_price'] = display_df['spot_price'].apply(lambda x: f"${x:.2f}")
display_df['dividend_yield'] = display_df['dividend_yield'].apply(lambda x: f"{x*100:.2f}%")
display_df.columns = ['Ticker', 'Company Name', 'Sector', 'Spot Price', 'Dividend Yield']
print(display_df.to_string(index=False))
```

---

## Exploratory Data Analysis

This subsection provides a comprehensive exploration of our dataset before applying the Black-Scholes model.

### Stock Data Summary Statistics

```{python}
#| label: eda-stock-stats
#| echo: true

print("=" * 80)
print("STOCK PRICE SUMMARY STATISTICS")
print("=" * 80)

# Calculate summary stats per stock
stock_stats = []
for ticker in stock_info['ticker']:
    hist = stock_history[stock_history['ticker'] == ticker]['close']
    info = stock_info[stock_info['ticker'] == ticker].iloc[0]
    
    stock_stats.append({
        'Ticker': ticker,
        'Sector': info['sector'],
        'Current Price': f"${info['spot_price']:.2f}",
        'Mean': f"${hist.mean():.2f}",
        'Std Dev': f"${hist.std():.2f}",
        'Min': f"${hist.min():.2f}",
        'Max': f"${hist.max():.2f}",
        'Volatility': f"{(hist.std()/hist.mean())*100:.1f}%"
    })

stock_stats_df = pd.DataFrame(stock_stats)
print(stock_stats_df.to_string(index=False))
```

### Options Data Summary

```{python}
#| label: eda-options-stats
#| echo: true

print("\n" + "=" * 80)
print("OPTIONS DATA SUMMARY")
print("=" * 80)

print(f"\nðŸ“Š CALL OPTIONS ({len(calls_df)} contracts):")
print("-" * 60)
print(f"  Strike Price:    Min=${calls_df['strike'].min():.2f}, Max=${calls_df['strike'].max():.2f}")
print(f"  Option Price:    Min=${calls_df['lastPrice'].min():.2f}, Max=${calls_df['lastPrice'].max():.2f}, Mean=${calls_df['lastPrice'].mean():.2f}")
print(f"  Implied Vol:     Min={calls_df['impliedVolatility'].min():.4f}, Max={calls_df['impliedVolatility'].max():.4f}")
print(f"  Volume:          Min={calls_df['volume'].min()}, Max={calls_df['volume'].max()}")
print(f"  Days to Expiry:  {calls_df['days_to_expiry'].iloc[0]} days")

print(f"\nðŸ“Š PUT OPTIONS ({len(puts_df)} contracts):")
print("-" * 60)
print(f"  Strike Price:    Min=${puts_df['strike'].min():.2f}, Max=${puts_df['strike'].max():.2f}")
print(f"  Option Price:    Min=${puts_df['lastPrice'].min():.2f}, Max=${puts_df['lastPrice'].max():.2f}, Mean=${puts_df['lastPrice'].mean():.2f}")
print(f"  Implied Vol:     Min={puts_df['impliedVolatility'].min():.4f}, Max={puts_df['impliedVolatility'].max():.4f}")
print(f"  Volume:          Min={puts_df['volume'].min()}, Max={puts_df['volume'].max()}")
print(f"  Days to Expiry:  {puts_df['days_to_expiry'].iloc[0]} days")
```

### Distribution of Option Prices

```{python}
#| label: fig-eda-price-dist
#| fig-cap: "Distribution of Option Prices by Type"
#| echo: true

fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# Call prices distribution
ax1 = axes[0]
ax1.hist(calls_df['lastPrice'], bins=30, color='#3498db', edgecolor='black', alpha=0.7)
ax1.axvline(calls_df['lastPrice'].mean(), color='red', linestyle='--', linewidth=2, label=f"Mean: ${calls_df['lastPrice'].mean():.2f}")
ax1.axvline(calls_df['lastPrice'].median(), color='green', linestyle='--', linewidth=2, label=f"Median: ${calls_df['lastPrice'].median():.2f}")
ax1.set_xlabel('Option Price ($)', fontsize=11)
ax1.set_ylabel('Frequency', fontsize=11)
ax1.set_title('Call Option Price Distribution', fontsize=13, fontweight='bold')
ax1.legend()
ax1.grid(True, alpha=0.3)

# Put prices distribution
ax2 = axes[1]
ax2.hist(puts_df['lastPrice'], bins=30, color='#e74c3c', edgecolor='black', alpha=0.7)
ax2.axvline(puts_df['lastPrice'].mean(), color='blue', linestyle='--', linewidth=2, label=f"Mean: ${puts_df['lastPrice'].mean():.2f}")
ax2.axvline(puts_df['lastPrice'].median(), color='green', linestyle='--', linewidth=2, label=f"Median: ${puts_df['lastPrice'].median():.2f}")
ax2.set_xlabel('Option Price ($)', fontsize=11)
ax2.set_ylabel('Frequency', fontsize=11)
ax2.set_title('Put Option Price Distribution', fontsize=13, fontweight='bold')
ax2.legend()
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print("\nðŸ“ˆ Key Observations:")
print(f"  â€¢ Call options are right-skewed (many low-priced OTM calls)")
print(f"  â€¢ Put options show similar right-skewed distribution")
print(f"  â€¢ Large gap between mean and median indicates outliers (deep ITM options)")
```

### Implied Volatility Distribution

```{python}
#| label: fig-eda-iv-dist
#| fig-cap: "Distribution of Implied Volatility"
#| echo: true

fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# Call IV distribution
ax1 = axes[0]
valid_iv_calls = calls_df[calls_df['impliedVolatility'] > 0.001]['impliedVolatility']
ax1.hist(valid_iv_calls, bins=30, color='#9b59b6', edgecolor='black', alpha=0.7)
ax1.axvline(valid_iv_calls.mean(), color='red', linestyle='--', linewidth=2, label=f"Mean: {valid_iv_calls.mean():.2%}")
ax1.set_xlabel('Implied Volatility', fontsize=11)
ax1.set_ylabel('Frequency', fontsize=11)
ax1.set_title('Call Options: IV Distribution', fontsize=13, fontweight='bold')
ax1.legend()
ax1.grid(True, alpha=0.3)

# Put IV distribution
ax2 = axes[1]
valid_iv_puts = puts_df[puts_df['impliedVolatility'] > 0.001]['impliedVolatility']
ax2.hist(valid_iv_puts, bins=30, color='#1abc9c', edgecolor='black', alpha=0.7)
ax2.axvline(valid_iv_puts.mean(), color='red', linestyle='--', linewidth=2, label=f"Mean: {valid_iv_puts.mean():.2%}")
ax2.set_xlabel('Implied Volatility', fontsize=11)
ax2.set_ylabel('Frequency', fontsize=11)
ax2.set_title('Put Options: IV Distribution', fontsize=13, fontweight='bold')
ax2.legend()
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# Count problematic IVs
low_iv_calls = (calls_df['impliedVolatility'] < 0.01).sum()
low_iv_puts = (puts_df['impliedVolatility'] < 0.01).sum()
print(f"\nâš ï¸  DATA QUALITY NOTE:")
print(f"  â€¢ Call options with IV < 1% (placeholder values): {low_iv_calls} ({low_iv_calls/len(calls_df)*100:.1f}%)")
print(f"  â€¢ Put options with IV < 1% (placeholder values): {low_iv_puts} ({low_iv_puts/len(puts_df)*100:.1f}%)")
print(f"  â€¢ These placeholder IVs will cause large BS pricing errors")
```

### Options by Strike Price and Moneyness

```{python}
#| label: fig-eda-moneyness
#| fig-cap: "Option Contracts by Moneyness"
#| echo: true

# Calculate moneyness for each option
for ticker in stock_info['ticker'].unique():
    spot = stock_info[stock_info['ticker'] == ticker]['spot_price'].values[0]
    calls_df.loc[calls_df['ticker'] == ticker, 'moneyness'] = calls_df.loc[calls_df['ticker'] == ticker, 'strike'] / spot
    puts_df.loc[puts_df['ticker'] == ticker, 'moneyness'] = puts_df.loc[puts_df['ticker'] == ticker, 'strike'] / spot

fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# Call moneyness
ax1 = axes[0]
ax1.hist(calls_df['moneyness'], bins=25, color='#3498db', edgecolor='black', alpha=0.7)
ax1.axvline(x=1.0, color='red', linestyle='--', linewidth=2, label='ATM (K=S)')
ax1.set_xlabel('Moneyness (K/S)', fontsize=11)
ax1.set_ylabel('Number of Contracts', fontsize=11)
ax1.set_title('Call Options: Moneyness Distribution', fontsize=13, fontweight='bold')
ax1.legend()
ax1.grid(True, alpha=0.3)

# Put moneyness
ax2 = axes[1]
ax2.hist(puts_df['moneyness'], bins=25, color='#e74c3c', edgecolor='black', alpha=0.7)
ax2.axvline(x=1.0, color='red', linestyle='--', linewidth=2, label='ATM (K=S)')
ax2.set_xlabel('Moneyness (K/S)', fontsize=11)
ax2.set_ylabel('Number of Contracts', fontsize=11)
ax2.set_title('Put Options: Moneyness Distribution', fontsize=13, fontweight='bold')
ax2.legend()
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# Categorize moneyness
def categorize(m, opt_type):
    if opt_type == 'call':
        if m < 0.95: return 'ITM'
        elif m <= 1.05: return 'ATM'
        else: return 'OTM'
    else:
        if m > 1.05: return 'ITM'
        elif m >= 0.95: return 'ATM'
        else: return 'OTM'

calls_df['money_cat'] = calls_df['moneyness'].apply(lambda x: categorize(x, 'call'))
puts_df['money_cat'] = puts_df['moneyness'].apply(lambda x: categorize(x, 'put'))

print("\nðŸ“Š MONEYNESS BREAKDOWN:")
print("\nCall Options:")
print(calls_df['money_cat'].value_counts())
print("\nPut Options:")
print(puts_df['money_cat'].value_counts())
```

### Options by Stock

```{python}
#| label: fig-eda-by-stock
#| fig-cap: "Number of Option Contracts per Stock"
#| echo: true

fig, ax = plt.subplots(figsize=(12, 5))

tickers = stock_info['ticker'].tolist()
call_counts = [len(calls_df[calls_df['ticker'] == t]) for t in tickers]
put_counts = [len(puts_df[puts_df['ticker'] == t]) for t in tickers]

x = np.arange(len(tickers))
width = 0.35

bars1 = ax.bar(x - width/2, call_counts, width, label='Calls', color='#3498db', edgecolor='black')
bars2 = ax.bar(x + width/2, put_counts, width, label='Puts', color='#e74c3c', edgecolor='black')

ax.set_xlabel('Stock Ticker', fontsize=11)
ax.set_ylabel('Number of Contracts', fontsize=11)
ax.set_title('Option Contracts per Stock', fontsize=13, fontweight='bold')
ax.set_xticks(x)
ax.set_xticklabels(tickers)
ax.legend()
ax.grid(True, alpha=0.3, axis='y')

# Add value labels on bars
for bar in bars1:
    height = bar.get_height()
    ax.annotate(f'{int(height)}', xy=(bar.get_x() + bar.get_width()/2, height),
                xytext=(0, 3), textcoords="offset points", ha='center', va='bottom', fontsize=9)
for bar in bars2:
    height = bar.get_height()
    ax.annotate(f'{int(height)}', xy=(bar.get_x() + bar.get_width()/2, height),
                xytext=(0, 3), textcoords="offset points", ha='center', va='bottom', fontsize=9)

plt.tight_layout()
plt.show()

print(f"\nðŸ“Š Total: {len(calls_df)} call options, {len(puts_df)} put options across {len(tickers)} stocks")
```

---

# Empirical Results

## Stock Price Trend Analysis

```{python}
#| label: fig-stock-trends
#| fig-cap: "Stock Price Trends During Study Period"
#| echo: true

fig, axes = plt.subplots(3, 3, figsize=(14, 10))
axes = axes.flatten()

sectors = {'Financial': ['BAC', 'JPM', 'WFC'],
           'Healthcare': ['MRK', 'PFE', 'UNH'],
           'Technology': ['AAPL', 'MSFT', 'NVDA']}

colors = {'Financial': '#2E86AB', 'Healthcare': '#A23B72', 'Technology': '#F18F01'}

for i, ticker in enumerate(stock_info['ticker']):
    ax = axes[i]
    data = stock_history[stock_history['ticker'] == ticker].copy()
    sector = stock_info[stock_info['ticker'] == ticker]['sector'].values[0]
    
    ax.plot(data['date'], data['close'], color=colors[sector], linewidth=2)
    ax.fill_between(data['date'], data['close'].min() * 0.98, data['close'], 
                    alpha=0.3, color=colors[sector])
    
    ax.set_title(f"{ticker} ({sector})", fontsize=12, fontweight='bold')
    ax.set_xlabel('')
    ax.tick_params(axis='x', rotation=45)
    
    pct_change = (data['close'].iloc[-1] / data['close'].iloc[0] - 1) * 100
    ax.annotate(f"{pct_change:+.1f}%", xy=(0.95, 0.95), xycoords='axes fraction',
                ha='right', va='top', fontsize=10, 
                color='green' if pct_change > 0 else 'red', fontweight='bold')

plt.suptitle('Stock Price Trends During Study Period', fontsize=14, fontweight='bold', y=1.02)
plt.tight_layout()
plt.show()
```

### Interpretation: Stock Price Trends

The stock price trend analysis reveals the market conditions during our study period. Key observations include:

1. **Volatility Differences by Sector**: Technology stocks (AAPL, MSFT, NVDA) generally exhibit higher price volatility compared to Financial (BAC, JPM, WFC) and Healthcare (MRK, PFE, UNH) stocks. This higher volatility in technology stocks directly impacts option pricing, as volatility is a key input to the Black-Scholes model.

2. **Market Direction**: The percentage changes shown in each chart indicate whether the stock was in an uptrend or downtrend during the study period. Stocks experiencing significant price movements may show larger pricing discrepancies between market and theoretical option prices.

3. **Implications for Option Pricing**: During periods of high volatility or rapid price changes, the Black-Scholes assumption of constant volatility becomes less valid, potentially leading to larger pricing errors.

---

## Blackâ€“Scholes Model Implementation and Pricing

```{python}
#| label: bs-model
#| echo: true

class BlackScholesModel:
    """Extended Black-Scholes model with dividend yield."""
    
    def __init__(self, S, K, T, r, sigma, delta=0):
        self.S, self.K, self.T, self.r, self.sigma, self.delta = S, K, T, r, sigma, delta
        self._compute_d()
    
    def _compute_d(self):
        if self.T <= 0 or self.sigma <= 0:
            self.d1 = self.d2 = np.nan
        else:
            self.d1 = (np.log(self.S/self.K) + (self.r - self.delta + 0.5*self.sigma**2)*self.T) / (self.sigma*np.sqrt(self.T))
            self.d2 = self.d1 - self.sigma*np.sqrt(self.T)
    
    def call_price(self):
        if self.T <= 0:
            return max(self.S - self.K, 0)
        return self.S * np.exp(-self.delta*self.T) * norm.cdf(self.d1) - self.K * np.exp(-self.r*self.T) * norm.cdf(self.d2)
    
    def put_price(self):
        if self.T <= 0:
            return max(self.K - self.S, 0)
        return self.K * np.exp(-self.r*self.T) * norm.cdf(-self.d2) - self.S * np.exp(-self.delta*self.T) * norm.cdf(-self.d1)


def compute_bs_prices(calls_df, puts_df, stock_info, risk_free_rate):
    """Compute Black-Scholes theoretical prices for all options."""
    
    calls_results, puts_results = [], []
    
    for _, row in calls_df.iterrows():
        ticker = row['ticker']
        stock = stock_info[stock_info['ticker'] == ticker].iloc[0]
        S, K = stock['spot_price'], row['strike']
        T = row['T'] if 'T' in row else row['days_to_expiry'] / 365
        delta, sigma = stock['dividend_yield'], row['impliedVolatility']
        market_price = row['lastPrice']
        
        bs = BlackScholesModel(S, K, T, risk_free_rate, sigma, delta)
        bs_price = bs.call_price()
        
        calls_results.append({
            'ticker': ticker, 'strike': K, 'T': T,
            'market_price': market_price, 'bs_price': bs_price,
            'error': market_price - bs_price,
            'pct_error': (market_price - bs_price) / market_price * 100 if market_price > 0 else np.nan,
            'sigma': sigma
        })
    
    for _, row in puts_df.iterrows():
        ticker = row['ticker']
        stock = stock_info[stock_info['ticker'] == ticker].iloc[0]
        S, K = stock['spot_price'], row['strike']
        T = row['T'] if 'T' in row else row['days_to_expiry'] / 365
        delta, sigma = stock['dividend_yield'], row['impliedVolatility']
        market_price = row['lastPrice']
        
        bs = BlackScholesModel(S, K, T, risk_free_rate, sigma, delta)
        bs_price = bs.put_price()
        
        puts_results.append({
            'ticker': ticker, 'strike': K, 'T': T,
            'market_price': market_price, 'bs_price': bs_price,
            'error': market_price - bs_price,
            'pct_error': (market_price - bs_price) / market_price * 100 if market_price > 0 else np.nan,
            'sigma': sigma
        })
    
    return pd.DataFrame(calls_results), pd.DataFrame(puts_results)

calls_results, puts_results = compute_bs_prices(calls_df, puts_df, stock_info, risk_free_rate)
print(f"Computed Black-Scholes prices for {len(calls_results)} calls and {len(puts_results)} puts")
```

---

## Paired Sample T-Test Results

### Call Options

```{python}
#| label: ttest-calls
#| echo: true

def perform_ttest(results_df, option_type):
    """Perform paired t-test for each stock."""
    test_results = []
    
    for ticker in results_df['ticker'].unique():
        data = results_df[results_df['ticker'] == ticker]
        if len(data) < 2:
            continue
        
        market = data['market_price'].values
        bs = data['bs_price'].values
        
        t_stat, p_value = ttest_rel(market, bs)
        mean_diff = np.mean(market - bs)
        std_diff = np.std(market - bs, ddof=1)
        
        test_results.append({
            'ticker': ticker, 'n': len(data),
            'mean_market': np.mean(market), 'mean_bs': np.mean(bs),
            'mean_diff': mean_diff, 'std_diff': std_diff,
            't_stat': t_stat, 'p_value': p_value,
            'significant': 'Yes' if p_value < 0.05 else 'No'
        })
    
    return pd.DataFrame(test_results)

calls_ttest = perform_ttest(calls_results, 'call')

print("=" * 80)
print("PAIRED SAMPLE T-TEST RESULTS: CALL OPTIONS")
print("=" * 80)
print(f"\nHâ‚€: No significant difference between market premium and Black-Scholes premium")
print(f"Hâ‚: Significant difference exists")
print(f"Significance level: Î± = 0.05\n")

display_calls = calls_ttest[['ticker', 'n', 'mean_diff', 'std_diff', 't_stat', 'p_value', 'significant']].copy()
display_calls.columns = ['Ticker', 'N', 'Mean Diff', 'Std Diff', 't-Statistic', 'p-Value', 'Significant?']
print(display_calls.to_string(index=False, float_format=lambda x: f"{x:.4f}"))

sig_count_calls = (calls_ttest['significant'] == 'Yes').sum()
print(f"\nâ†’ Significant difference found in {sig_count_calls} out of {len(calls_ttest)} stocks")
```

### Put Options

```{python}
#| label: ttest-puts
#| echo: true

puts_ttest = perform_ttest(puts_results, 'put')

print("=" * 80)
print("PAIRED SAMPLE T-TEST RESULTS: PUT OPTIONS")
print("=" * 80)
print(f"\nHâ‚€: No significant difference between market premium and Black-Scholes premium")
print(f"Hâ‚: Significant difference exists")
print(f"Significance level: Î± = 0.05\n")

display_puts = puts_ttest[['ticker', 'n', 'mean_diff', 'std_diff', 't_stat', 'p_value', 'significant']].copy()
display_puts.columns = ['Ticker', 'N', 'Mean Diff', 'Std Diff', 't-Statistic', 'p-Value', 'Significant?']
print(display_puts.to_string(index=False, float_format=lambda x: f"{x:.4f}"))

sig_count_puts = (puts_ttest['significant'] == 'Yes').sum()
print(f"\nâ†’ Significant difference found in {sig_count_puts} out of {len(puts_ttest)} stocks")
```

### Results Visualization: P-Values by Stock

```{python}
#| label: fig-ttest-results
#| fig-cap: "Paired T-Test Results: p-Values by Stock and Option Type"
#| echo: true

fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Call options
ax1 = axes[0]
colors_call = ['#2ecc71' if p > 0.05 else '#e74c3c' for p in calls_ttest['p_value']]
bars1 = ax1.barh(calls_ttest['ticker'], calls_ttest['p_value'], color=colors_call, edgecolor='black')
ax1.axvline(x=0.05, color='black', linestyle='--', linewidth=2, label='Î± = 0.05')
ax1.set_xlabel('p-Value', fontsize=12)
ax1.set_title('Call Options: p-Values by Stock', fontsize=14, fontweight='bold')
ax1.legend()

for bar, p in zip(bars1, calls_ttest['p_value']):
    ax1.text(bar.get_width() + 0.002, bar.get_y() + bar.get_height()/2, 
             f'{p:.4f}', va='center', fontsize=9)

# Put options
ax2 = axes[1]
colors_put = ['#2ecc71' if p > 0.05 else '#e74c3c' for p in puts_ttest['p_value']]
bars2 = ax2.barh(puts_ttest['ticker'], puts_ttest['p_value'], color=colors_put, edgecolor='black')
ax2.axvline(x=0.05, color='black', linestyle='--', linewidth=2, label='Î± = 0.05')
ax2.set_xlabel('p-Value', fontsize=12)
ax2.set_title('Put Options: p-Values by Stock', fontsize=14, fontweight='bold')
ax2.legend()

for bar, p in zip(bars2, puts_ttest['p_value']):
    ax2.text(bar.get_width() + 0.002, bar.get_y() + bar.get_height()/2, 
             f'{p:.4f}', va='center', fontsize=9)

plt.tight_layout()
plt.show()

print("\nLegend: Green = Not Significant (p > 0.05), Red = Significant (p < 0.05)")
```

### Interpretation: P-Value Analysis

The p-value charts provide a visual summary of the hypothesis test results for each stock:

**Call Options (Left Panel):**

- All nine stocks show p-values below the significance threshold (Î± = 0.05), indicated by red bars
- This means we **reject the null hypothesis** for all call options
- The Black-Scholes model shows **statistically significant pricing differences** from market prices for all call options analyzed
- PFE shows the highest p-value (0.0166) among calls, but still significant
- The remaining stocks have very small p-values (< 0.002), indicating strong evidence against the null hypothesis

**Put Options (Right Panel):**

- **AAPL is the only stock** where we fail to reject the null hypothesis (p = 0.5261, shown in green)
- For AAPL put options, there is no statistically significant difference between market and BS prices
- All other stocks show significant differences (p < 0.05)
- This suggests the Black-Scholes model is **not suitable for pricing put options** in most cases

**Key Finding:** These results contrast with Salami (2024), who found the BS model works better for calls than puts. Our analysis shows significant mispricing for **both** option types, with only AAPL puts showing no significant difference.

---

## Pricing Error Analysis

### Distribution of Pricing Errors by Stock

```{python}
#| label: fig-error-distribution
#| fig-cap: "Distribution of Pricing Errors by Stock (Market Price - BS Price)"
#| echo: true

fig, axes = plt.subplots(3, 3, figsize=(14, 12))
axes = axes.flatten()

for i, ticker in enumerate(stock_info['ticker']):
    ax = axes[i]
    
    call_errors = calls_results[calls_results['ticker'] == ticker]['error']
    put_errors = puts_results[puts_results['ticker'] == ticker]['error']
    
    ax.hist(call_errors, bins=15, alpha=0.6, label='Calls', color='#3498db', edgecolor='black')
    ax.hist(put_errors, bins=15, alpha=0.6, label='Puts', color='#e74c3c', edgecolor='black')
    
    ax.axvline(x=0, color='black', linestyle='--', linewidth=1.5)
    ax.axvline(x=call_errors.mean(), color='#3498db', linestyle='-', linewidth=2, alpha=0.8)
    ax.axvline(x=put_errors.mean(), color='#e74c3c', linestyle='-', linewidth=2, alpha=0.8)
    
    ax.set_title(f'{ticker}', fontsize=12, fontweight='bold')
    ax.set_xlabel('Pricing Error ($)')
    ax.legend(fontsize=9)

plt.suptitle('Distribution of Pricing Errors (Market - BS)', fontsize=14, fontweight='bold', y=1.02)
plt.tight_layout()
plt.show()
```

### Interpretation: Error Distribution

The histograms reveal important patterns in how the Black-Scholes model deviates from market prices:

**Systematic Patterns Observed:**

1. **Call Options (Blue)** consistently show **positive mean errors** (vertical blue lines to the right of zero), meaning market prices are **higher** than BS theoretical prices. The Black-Scholes model **underprices** call options.

2. **Put Options (Red)** consistently show **negative mean errors** (vertical red lines to the left of zero), meaning market prices are **lower** than BS theoretical prices. The Black-Scholes model **overprices** put options.

3. **Stock-Specific Observations:**
   - **JPM and UNH**: Show the widest error distributions, indicating high pricing variability
   - **NVDA**: Shows relatively tight distributions centered near zero, especially for puts
   - **MRK**: Put errors are notably skewed negative with some extreme values

4. **Implications:** The systematic nature of these errors (calls underpriced, puts overpriced) suggests the model fails to capture some market dynamics, possibly related to volatility skew or risk premiums not accounted for in the BS assumptions.

---

### Mean Pricing Error by Stock

```{python}
#| label: fig-mean-errors
#| fig-cap: "Mean Pricing Errors by Stock (Market Price - BS Price)"
#| echo: true

fig, ax = plt.subplots(figsize=(14, 6))

x = np.arange(len(stock_info))
width = 0.35

call_means = [calls_results[calls_results['ticker'] == t]['error'].mean() for t in stock_info['ticker']]
put_means = [puts_results[puts_results['ticker'] == t]['error'].mean() for t in stock_info['ticker']]

bars1 = ax.bar(x - width/2, call_means, width, label='Call Options', color='#3498db', edgecolor='black')
bars2 = ax.bar(x + width/2, put_means, width, label='Put Options', color='#e74c3c', edgecolor='black')

ax.axhline(y=0, color='black', linestyle='-', linewidth=0.5)
ax.set_xlabel('Stock', fontsize=12)
ax.set_ylabel('Mean Pricing Error ($)', fontsize=12)
ax.set_title('Mean Pricing Error by Stock (Market Price - BS Price)', fontsize=14, fontweight='bold')
ax.set_xticks(x)
ax.set_xticklabels(stock_info['ticker'])
ax.legend()

for bar in bars1:
    height = bar.get_height()
    ax.annotate(f'{height:.3f}', xy=(bar.get_x() + bar.get_width()/2, height),
                xytext=(0, 3 if height >= 0 else -12), textcoords="offset points",
                ha='center', va='bottom' if height >= 0 else 'top', fontsize=8)

for bar in bars2:
    height = bar.get_height()
    ax.annotate(f'{height:.3f}', xy=(bar.get_x() + bar.get_width()/2, height),
                xytext=(0, 3 if height >= 0 else -12), textcoords="offset points",
                ha='center', va='bottom' if height >= 0 else 'top', fontsize=8)

plt.tight_layout()
plt.show()
```

### Interpretation: Mean Pricing Errors

This chart quantifies the average pricing discrepancy for each stock:

**Key Findings:**

1. **Consistent Directional Bias:**
   - **All call options** show positive mean errors (blue bars above zero)
   - **Most put options** show negative mean errors (red bars below zero)
   - Exception: NVDA puts show a small positive mean error ($1.414)

2. **Magnitude of Errors:**
   - **UNH** has the largest call option error (+$24.256) and put option error (-$28.807)
   - **JPM** shows substantial errors: +$16.00 for calls, -$26.783 for puts
   - **AAPL** has relatively small errors: +$3.458 for calls, -$0.337 for puts (explaining why AAPL puts passed the t-test)

3. **Sector Patterns:**
   - **Healthcare stocks (MRK, PFE, UNH)**: Show large absolute errors, especially UNH
   - **Financial stocks (BAC, JPM, WFC)**: JPM dominates with large errors
   - **Technology stocks**: More moderate errors, with NVDA showing the smallest

4. **Economic Significance:** Even when errors are statistically significant, their dollar magnitude matters for trading decisions. A $0.34 error (AAPL puts) may be within bid-ask spreads, while a $28 error (UNH puts) represents substantial mispricing.

---

### Standard Deviation of Pricing Errors

```{python}
#| label: fig-std-errors
#| fig-cap: "Standard Deviation of Pricing Errors by Stock"
#| echo: true

fig, ax = plt.subplots(figsize=(14, 6))

call_stds = [calls_results[calls_results['ticker'] == t]['error'].std() for t in stock_info['ticker']]
put_stds = [puts_results[puts_results['ticker'] == t]['error'].std() for t in stock_info['ticker']]

bars1 = ax.bar(x - width/2, call_stds, width, label='Call Options', color='#3498db', edgecolor='black')
bars2 = ax.bar(x + width/2, put_stds, width, label='Put Options', color='#e74c3c', edgecolor='black')

ax.set_xlabel('Stock', fontsize=12)
ax.set_ylabel('Standard Deviation ($)', fontsize=12)
ax.set_title('Standard Deviation of Pricing Errors by Stock', fontsize=14, fontweight='bold')
ax.set_xticks(x)
ax.set_xticklabels(stock_info['ticker'])
ax.legend()

plt.tight_layout()
plt.show()

min_std_idx = np.argmin(np.array(call_stds) + np.array(put_stds))
max_std_idx = np.argmax(np.array(call_stds) + np.array(put_stds))

print(f"\nLowest fluctuation (most consistent): {stock_info['ticker'].iloc[min_std_idx]}")
print(f"Highest fluctuation (most variable): {stock_info['ticker'].iloc[max_std_idx]}")
```

### Interpretation: Standard Deviation Analysis

Standard deviation measures the **variability** or **consistency** of pricing errors:

**Key Observations:**

1. **Most Variable (Highest Std):**
   - **UNH** shows the highest standard deviation (~$23-24) for both calls and puts
   - **JPM** also shows high variability (~$20-21)
   - High standard deviation indicates **inconsistent** model performance across different strike prices

2. **Most Consistent (Lowest Std):**
   - **NVDA** shows the lowest standard deviation (~$2.5) for both option types
   - **PFE** also shows relatively low variability
   - Low standard deviation suggests the model error is **predictable** and consistent

3. **Stock Price Level Effect:**
   - Higher-priced stocks (UNH ~$520, JPM ~$196) tend to have higher absolute standard deviations
   - Lower-priced stocks (PFE ~$27, BAC ~$37) have lower absolute standard deviations
   - This is expected since option premiums scale with stock price

4. **Implications for Trading:**
   - Stocks with low std (like NVDA) may be more suitable for BS-based trading strategies
   - Stocks with high std (like UNH) require additional risk adjustments when using BS prices

---

## Sector Analysis

```{python}
#| label: fig-sector-analysis
#| fig-cap: "Pricing Errors by Sector"
#| echo: true

calls_with_sector = calls_results.merge(stock_info[['ticker', 'sector']], on='ticker')
puts_with_sector = puts_results.merge(stock_info[['ticker', 'sector']], on='ticker')

fig, axes = plt.subplots(1, 2, figsize=(14, 5))

sectors = ['Financial', 'Healthcare', 'Technology']
sector_colors = ['#2E86AB', '#A23B72', '#F18F01']

# Call options
ax1 = axes[0]
call_sector_data = [calls_with_sector[calls_with_sector['sector'] == s]['error'] for s in sectors]
bp1 = ax1.boxplot(call_sector_data, labels=sectors, patch_artist=True)
for patch, color in zip(bp1['boxes'], sector_colors):
    patch.set_facecolor(color)
    patch.set_alpha(0.7)
ax1.axhline(y=0, color='black', linestyle='--', linewidth=1)
ax1.set_ylabel('Pricing Error ($)', fontsize=12)
ax1.set_title('Call Options: Pricing Error by Sector', fontsize=14, fontweight='bold')

# Put options
ax2 = axes[1]
put_sector_data = [puts_with_sector[puts_with_sector['sector'] == s]['error'] for s in sectors]
bp2 = ax2.boxplot(put_sector_data, labels=sectors, patch_artist=True)
for patch, color in zip(bp2['boxes'], sector_colors):
    patch.set_facecolor(color)
    patch.set_alpha(0.7)
ax2.axhline(y=0, color='black', linestyle='--', linewidth=1)
ax2.set_ylabel('Pricing Error ($)', fontsize=12)
ax2.set_title('Put Options: Pricing Error by Sector', fontsize=14, fontweight='bold')

plt.tight_layout()
plt.show()
```

### Interpretation: Sector Analysis

The box plots reveal sector-specific patterns in Black-Scholes pricing accuracy:

**Call Options (Left Panel):**

1. **Financial Sector (Blue):** Median error near $5, relatively tight interquartile range, with some outliers above $50. The BS model consistently underprices financial call options.

2. **Healthcare Sector (Pink):** Widest distribution with median around $5-10, but extreme outliers reaching $60+. High variability suggests sector-specific factors affect pricing.

3. **Technology Sector (Orange):** Median close to zero with a tighter distribution than Healthcare. However, outliers exist on both sides, indicating occasional large deviations.

**Put Options (Right Panel):**

1. **Financial Sector:** Median around -$10, with errors ranging from -$60 to near zero. The BS model significantly overprices financial put options.

2. **Healthcare Sector:** Similar pattern to Financial, with median around -$15 and wide variability.

3. **Technology Sector:** **Best performance** with median near zero and the tightest distribution. This explains why AAPL (Technology) was the only stock where puts passed the t-test.

**Sector Conclusions:**
- **Technology stocks** show the best alignment with Black-Scholes prices
- **Healthcare stocks** show the highest variability and largest errors
- **Financial stocks** show consistent bias (underpricing calls, overpricing puts)

---

## Market vs Black-Scholes Price Comparison

```{python}
#| label: fig-market-vs-bs
#| fig-cap: "Market Price vs Black-Scholes Price Scatter Plot"
#| echo: true

fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Call options
ax1 = axes[0]
for sector, color in zip(sectors, sector_colors):
    data = calls_with_sector[calls_with_sector['sector'] == sector]
    ax1.scatter(data['bs_price'], data['market_price'], alpha=0.6, 
                label=sector, color=color, s=50, edgecolor='white')

max_val = max(calls_results['market_price'].max(), calls_results['bs_price'].max())
ax1.plot([0, max_val], [0, max_val], 'k--', linewidth=2, label='Perfect Fit')
ax1.set_xlabel('Black-Scholes Price ($)', fontsize=12)
ax1.set_ylabel('Market Price ($)', fontsize=12)
ax1.set_title('Call Options: Market vs BS Price', fontsize=14, fontweight='bold')
ax1.legend()

# Put options
ax2 = axes[1]
for sector, color in zip(sectors, sector_colors):
    data = puts_with_sector[puts_with_sector['sector'] == sector]
    ax2.scatter(data['bs_price'], data['market_price'], alpha=0.6, 
                label=sector, color=color, s=50, edgecolor='white')

max_val = max(puts_results['market_price'].max(), puts_results['bs_price'].max())
ax2.plot([0, max_val], [0, max_val], 'k--', linewidth=2, label='Perfect Fit')
ax2.set_xlabel('Black-Scholes Price ($)', fontsize=12)
ax2.set_ylabel('Market Price ($)', fontsize=12)
ax2.set_title('Put Options: Market vs BS Price', fontsize=14, fontweight='bold')
ax2.legend()

plt.tight_layout()
plt.show()
```

### Interpretation: Market vs BS Price Scatter

The scatter plots provide a visual assessment of how well Black-Scholes prices match market prices:

**Perfect Fit Line:** The dashed diagonal line represents perfect agreement (Market Price = BS Price). Points above the line indicate BS underpricing; points below indicate BS overpricing.

**Call Options (Left Panel):**

- Most points lie **above** the perfect fit line
- This confirms the BS model **systematically underprices** call options
- Technology stocks (orange) cluster closest to the line at lower price levels
- Healthcare and Financial stocks show larger deviations at higher prices
- The underpricing becomes more pronounced for expensive options

**Put Options (Right Panel):**

- Most points lie **below** the perfect fit line
- This confirms the BS model **systematically overprices** put options
- Technology stocks (orange) show the best fit, clustering around the line
- Healthcare stocks (pink) show significant deviation below the line
- The pattern suggests market participants pay less for puts than BS predicts

**Key Insight:** The systematic positioning of points relative to the perfect fit line indicates a **consistent bias** in the Black-Scholes model, not random error. This suggests market factors (like volatility skew or risk premiums) that the model doesn't capture.

---

# Why Does Black-Scholes Misprice Options?

The Black-Scholes model makes several simplifying assumptions that don't hold in real markets. This section diagnoses the **sources of mispricing** in our data.

## 1. Volatility Smile Effect

The BS model assumes **constant volatility** across all strikes. In reality, implied volatility varies with moneyness (the "volatility smile" or "skew").

```{python}
#| label: fig-volatility-smile
#| fig-cap: "Implied Volatility vs Moneyness (Volatility Smile)"
#| echo: true

fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# Calculate moneyness for each option
for ticker in stock_info['ticker'].unique():
    spot = stock_info[stock_info['ticker'] == ticker]['spot_price'].values[0]
    
    # Calls
    mask_c = calls_results['ticker'] == ticker
    if mask_c.sum() > 0:
        calls_results.loc[mask_c, 'moneyness'] = calls_results.loc[mask_c, 'strike'] / spot
    
    # Puts
    mask_p = puts_results['ticker'] == ticker
    if mask_p.sum() > 0:
        puts_results.loc[mask_p, 'moneyness'] = puts_results.loc[mask_p, 'strike'] / spot

# Plot volatility smile for calls
ax1 = axes[0]
for ticker in calls_results['ticker'].unique():
    data = calls_results[calls_results['ticker'] == ticker]
    ax1.scatter(data['moneyness'], data['sigma'], alpha=0.6, label=ticker, s=30)
ax1.axvline(x=1.0, color='red', linestyle='--', alpha=0.5, label='ATM (K=S)')
ax1.set_xlabel('Moneyness (K/S)', fontsize=11)
ax1.set_ylabel('Implied Volatility', fontsize=11)
ax1.set_title('Call Options: Volatility Smile', fontsize=13, fontweight='bold')
ax1.legend(loc='upper right', fontsize=8)
ax1.grid(True, alpha=0.3)

# Plot volatility smile for puts
ax2 = axes[1]
for ticker in puts_results['ticker'].unique():
    data = puts_results[puts_results['ticker'] == ticker]
    ax2.scatter(data['moneyness'], data['sigma'], alpha=0.6, label=ticker, s=30)
ax2.axvline(x=1.0, color='red', linestyle='--', alpha=0.5, label='ATM (K=S)')
ax2.set_xlabel('Moneyness (K/S)', fontsize=11)
ax2.set_ylabel('Implied Volatility', fontsize=11)
ax2.set_title('Put Options: Volatility Smile', fontsize=13, fontweight='bold')
ax2.legend(loc='upper right', fontsize=8)
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print("\nðŸ“Š VOLATILITY SMILE ANALYSIS:")
print("If you see a U-shape or skew pattern, that's the volatility smile/skew.")
print("BS assumes FLAT volatility, so it misprices OTM and ITM options.")
```

## 2. Pricing Error vs Moneyness

Deep ITM and OTM options typically have larger pricing errors because the volatility smile effect is strongest there.

```{python}
#| label: fig-error-vs-moneyness
#| fig-cap: "Pricing Error vs Moneyness"
#| echo: true

fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# Calls
ax1 = axes[0]
ax1.scatter(calls_results['moneyness'], calls_results['error'], alpha=0.5, c='blue', s=30)
ax1.axhline(y=0, color='red', linestyle='--', alpha=0.7)
ax1.axvline(x=1.0, color='green', linestyle='--', alpha=0.5)
ax1.set_xlabel('Moneyness (K/S)', fontsize=11)
ax1.set_ylabel('Pricing Error ($)', fontsize=11)
ax1.set_title('Calls: Error vs Moneyness', fontsize=13, fontweight='bold')
ax1.grid(True, alpha=0.3)

# Puts
ax2 = axes[1]
ax2.scatter(puts_results['moneyness'], puts_results['error'], alpha=0.5, c='red', s=30)
ax2.axhline(y=0, color='red', linestyle='--', alpha=0.7)
ax2.axvline(x=1.0, color='green', linestyle='--', alpha=0.5)
ax2.set_xlabel('Moneyness (K/S)', fontsize=11)
ax2.set_ylabel('Pricing Error ($)', fontsize=11)
ax2.set_title('Puts: Error vs Moneyness', fontsize=13, fontweight='bold')
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# Calculate error by moneyness bucket
print("\nðŸ“Š PRICING ERROR BY MONEYNESS BUCKET:")
print("=" * 60)

def categorize_moneyness(m):
    if m < 0.90: return 'Deep ITM (<0.90)'
    elif m < 0.97: return 'ITM (0.90-0.97)'
    elif m <= 1.03: return 'ATM (0.97-1.03)'
    elif m <= 1.10: return 'OTM (1.03-1.10)'
    else: return 'Deep OTM (>1.10)'

calls_results['money_cat'] = calls_results['moneyness'].apply(categorize_moneyness)
puts_results['money_cat'] = puts_results['moneyness'].apply(categorize_moneyness)

print("\nCALL OPTIONS:")
call_summary = calls_results.groupby('money_cat')['error'].agg(['count', 'mean', 'std']).round(2)
print(call_summary)

print("\nPUT OPTIONS:")
put_summary = puts_results.groupby('money_cat')['error'].agg(['count', 'mean', 'std']).round(2)
print(put_summary)
```

## 3. Key Reasons for Mispricing

```{python}
#| label: mispricing-reasons
#| echo: true

print("=" * 70)
print("WHY BLACK-SCHOLES MISPRICES OPTIONS")
print("=" * 70)

# Calculate some diagnostics
avg_call_error = calls_results['error'].mean()
avg_put_error = puts_results['error'].mean()
call_overpriced = (calls_results['error'] > 0).sum() / len(calls_results) * 100
put_overpriced = (puts_results['error'] > 0).sum() / len(puts_results) * 100

print(f"""
ðŸ“Œ DIAGNOSTIC SUMMARY:
   â€¢ Average Call Error: ${avg_call_error:.2f} (BS {'overprices' if avg_call_error > 0 else 'underprices'})
   â€¢ Average Put Error:  ${avg_put_error:.2f} (BS {'overprices' if avg_put_error > 0 else 'underprices'})
   â€¢ Call options overpriced by BS: {call_overpriced:.1f}%
   â€¢ Put options overpriced by BS:  {put_overpriced:.1f}%

ðŸ” SOURCES OF MISPRICING:

1. VOLATILITY SMILE/SKEW
   â€¢ BS assumes constant volatility across all strikes
   â€¢ Market IV is higher for OTM puts (crash protection premium)
   â€¢ This causes systematic underpricing of OTM puts by BS

2. DIVIDEND YIELD ESTIMATION  
   â€¢ BS uses continuous dividend yield approximation
   â€¢ Real dividend timing affects option values
   â€¢ High dividend stocks (like PFE at 6.65%) show larger errors

3. AMERICAN vs EUROPEAN OPTIONS
   â€¢ Our BS formula is for European options
   â€¢ US equity options are American-style (early exercise allowed)
   â€¢ American puts are worth MORE than European puts (early exercise value)
   â€¢ This causes BS to UNDERPRICE put options

4. MARKET MICROSTRUCTURE
   â€¢ Bid-ask spreads cause deviation from theoretical prices
   â€¢ Low volume options have stale/unreliable prices
   â€¢ Market makers add risk premiums

5. JUMP RISK / FAT TAILS
   â€¢ BS assumes log-normal returns (no jumps)
   â€¢ Real markets have crash risk (fat tails)
   â€¢ OTM puts are priced higher due to crash protection
""")
```

---

# Summary and Conclusions

## Summary of Results

```{python}
#| label: summary-table
#| echo: true

print("=" * 80)
print("SUMMARY OF PAIRED SAMPLE T-TEST RESULTS")
print("=" * 80)

summary_data = []
for ticker in stock_info['ticker']:
    call_row = calls_ttest[calls_ttest['ticker'] == ticker].iloc[0]
    put_row = puts_ttest[puts_ttest['ticker'] == ticker].iloc[0]
    
    summary_data.append({
        'Ticker': ticker,
        'Call p-value': call_row['p_value'],
        'Call Sig?': call_row['significant'],
        'Put p-value': put_row['p_value'],
        'Put Sig?': put_row['significant']
    })

summary_df = pd.DataFrame(summary_data)
print("\n" + summary_df.to_string(index=False))

call_not_sig = (calls_ttest['significant'] == 'No').sum()
put_not_sig = (puts_ttest['significant'] == 'No').sum()

print(f"\n" + "=" * 80)
print("STATISTICAL SUMMARY")
print("=" * 80)
print(f"""
CALL OPTIONS:
  â€¢ No significant difference: {call_not_sig} out of {len(calls_ttest)} stocks ({call_not_sig/len(calls_ttest)*100:.0f}%)
  â€¢ Significant difference: {len(calls_ttest) - call_not_sig} out of {len(calls_ttest)} stocks ({(len(calls_ttest) - call_not_sig)/len(calls_ttest)*100:.0f}%)

PUT OPTIONS:
  â€¢ No significant difference: {put_not_sig} out of {len(puts_ttest)} stocks ({put_not_sig/len(puts_ttest)*100:.0f}%)
  â€¢ Significant difference: {len(puts_ttest) - put_not_sig} out of {len(puts_ttest)} stocks ({(len(puts_ttest) - put_not_sig)/len(puts_ttest)*100:.0f}%)
""")
```

## Conclusions

Based on the comprehensive empirical analysis using paired sample t-tests on nine stocks across three sectors (Financial, Healthcare, and Technology), this study reaches the following conclusions:

### Primary Findings

1. **Call Options:** The Black-Scholes model shows **statistically significant pricing differences** from market prices for **all nine stocks** (100%). The model consistently **underprices** call options, with mean errors ranging from $1.22 (NVDA) to $24.26 (UNH). Therefore, the Black-Scholes model **cannot be reliably used** to price call options in the current U.S. stock market.

2. **Put Options:** The Black-Scholes model shows significant pricing differences for **eight out of nine stocks** (89%). Only **AAPL** (p = 0.5261) showed no significant difference. The model consistently **overprices** put options, with mean errors ranging from -$0.34 (AAPL) to -$28.81 (UNH). Therefore, the Black-Scholes model is **not suitable** for pricing put options, except potentially for certain Technology stocks like AAPL.

3. **Sector Differences:**
   - **Technology sector** shows the best alignment with Black-Scholes prices, with smaller and more consistent errors
   - **Healthcare sector** shows the largest errors and highest variability
   - **Financial sector** shows moderate errors with consistent bias patterns

### Comparison with Prior Research

Our findings **contrast** with Salami (2024), who found that the Black-Scholes model works better for call options (7 out of 9 stocks) than put options (4 out of 9 stocks). Our analysis shows:

- **Calls**: 0 out of 9 stocks show no significant difference (vs. 7/9 in Salami 2024)
- **Puts**: 1 out of 9 stocks show no significant difference (vs. 4/9 in Salami 2024)

This discrepancy may be attributed to:

1. **Different market conditions**: Our study uses current market data, while Salami (2024) used data from May-June 2022
2. **Market volatility regime**: Current market conditions may feature different volatility dynamics
3. **Economic factors**: Interest rate environment, inflation expectations, and market sentiment have changed significantly

### Possible Reasons for Model Mispricing

The systematic mispricing observed can be attributed to violations of Black-Scholes assumptions:

1. **Volatility is not constant**: The volatility smile/skew observed in options markets contradicts the constant volatility assumption
2. **Returns are not normally distributed**: Real market returns exhibit fat tails and negative skewness
3. **Markets are not frictionless**: Transaction costs, bid-ask spreads, and liquidity constraints affect prices
4. **Interest rates are dynamic**: The assumption of constant risk-free rates is violated in current market conditions
5. **Early exercise premium**: American-style options may have early exercise value not captured by the European-style BS model

---

# Future Work

Based on the findings and limitations of this study, several directions for future research are recommended:

## 1. Alternative Pricing Models

- **Heston Stochastic Volatility Model**: Incorporate stochastic volatility to address the volatility smile
- **SABR Model**: Consider the SABR (Stochastic Alpha, Beta, Rho) model for interest rate derivatives
- **Jump-Diffusion Models**: Implement Merton's jump-diffusion model to capture sudden price movements
- **Local Volatility Models**: Use Dupire's local volatility framework

## 2. Extended Empirical Analysis

- **Longer Time Period**: Conduct analysis over multiple years to assess model performance across different market cycles
- **More Stocks**: Expand the sample to include mid-cap and small-cap stocks
- **Different Markets**: Compare results across international markets (European, Asian exchanges)
- **Different Asset Classes**: Test the model on index options, ETF options, and commodity options

## 3. Machine Learning Approaches

- **Neural Network Pricing**: Develop deep learning models for option pricing
- **Ensemble Methods**: Combine multiple models to improve pricing accuracy
- **Feature Engineering**: Incorporate additional market factors (sentiment, order flow, macroeconomic indicators)

## 4. Market Condition Analysis

- **Crisis Periods**: Study model performance during market stress (COVID-19, 2008 financial crisis)
- **Volatility Regimes**: Analyze pricing accuracy in high vs. low volatility environments
- **Interest Rate Environments**: Compare results across different monetary policy regimes

## 5. Practical Applications

- **Trading Strategy Development**: Develop strategies that exploit systematic mispricing
- **Risk Management**: Quantify the impact of model error on hedging effectiveness
- **Model Calibration**: Develop improved calibration techniques for practical use

---

# References

1. Black, F., & Scholes, M. (1973). The pricing of options and corporate liabilities. *Journal of Political Economy*, 81(3), 637-654.

2. Merton, R. C. (1973). Theory of rational option pricing. *Bell Journal of Economics and Management Science*, 4(1), 141-183.

3. Corrado, C. J., & Miller, T. W. (1996). A note on a simple, accurate formula to compute implied standard deviations. *Journal of Banking & Finance*, 20(3), 595-603.

4. Salami, M. F. (2024). Empirical examination of the Blackâ€“Scholes model: evidence from the United States stock market. *Frontiers in Applied Mathematics and Statistics*, 10, 1216386.

5. Ghasemi, A., & Zahediasl, S. (2012). Normality tests for statistical analysis: a guide for non-statisticians. *International Journal of Endocrinology and Metabolism*, 10(2), 486-489.

6. Hull, J. C. (2018). *Options, Futures, and Other Derivatives* (10th ed.). Pearson Education.

7. Heston, S. L. (1993). A closed-form solution for options with stochastic volatility with applications to bond and currency options. *The Review of Financial Studies*, 6(2), 327-343.
